"""
""" CREDITS: @mislav @amix @garybernhardt
"""

""" General Settings
set modelines=0
set nomodeline
set nocompatible
set fileencoding=utf-8
set spelllang=en_us

" Disable copy-as-rtf on non-Macs
if has("unix")
  let s:uname = system("uname -s")
  if s:uname != "Darwin\n"
    let g:loaded_copy_as_rtf = 1
  endif
endif

" autoloading
runtime bundle/vim-pathogen/autoload/pathogen.vim
call pathogen#infect()

" Enable filetype detection
filetype plugin indent on

" coding defaults (may be overridden by plugins/filetypes below)
syntax on
set expandtab
set backspace=start,indent,eol
set wrap
set shiftround

" turn off matching paren highlighting
let loaded_matchparen = 1

" $VIMCOLORS is set in iTerm profile
if empty($VIMCOLORS)
  colorscheme base16-tomorrow
  set background=dark
else
  colorscheme $VIMCOLORS
endif

highlight CursorLineNR ctermfg=DarkGreen

" more info
set number
set relativenumber
set showmode
set showcmd
set ruler
set laststatus=2
set cursorline

" always keep the cursor line in the middle of the screen if possible
set scrolloff=999

" smart(ish) searching
set incsearch
set nohlsearch
set smartcase
set wrapscan

" file & dir matching mode
set wildmode=list:longest

" Make tab completion for files/buffers act like bash/readline
set wildmenu

" remove binary files from completion menus
set wildignore+=*.o,*.obj,*.class,*.png,*.jpg,*.jpeg,*.gif,*.ico,*.pdf,*.doc,*.docx,*.ppt,*.pptx,*.xls,*.xlsx,tags
set wildignore+=*vendor/cache/*,*/vendor/ruby/*,*/tmp/*,*/log/*,*/.chef/checksums/*,*/node_modules/*,public/assets*
if has('wildignorecase')
  set wildignorecase
endif

set complete=.,w,b,u,t,i,]
" inserts the longest common text of all matches and display menu even if
" there's only one match
set completeopt=longest,menuone,preview

function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
    else
        return "\<c-p>"
    endif
endfunction
inoremap <Tab> <c-r>=InsertTabWrapper()<cr>
" remember
set history=256

" shut up
set noerrorbells
set novisualbell
set t_vb=

" files - use version control instead
set nobackup
set nowritebackup
set noswapfile

"When on a buffer becomes hidden when it is abandoned.
set hidden

" don't litter my working directory
set directory=~/.tmp,/var/tmp,/tmp

" auto-fetch changes from other sources
set autoread

" auto-write when suspending (^Z) etc
set autowrite

" i used to think folding > sliced bread
set nofoldenable

" Make sure the current window is always wide & tall enough
set winwidth=84

" We have to have a winheight bigger than we want to set winminheight. But if
" we set winheight to be huge before winminheight, the winminheight set will
" fail.
" set winheight=5
" set winminheight=5
" set winheight=999
set equalalways
set eadirection=hor

" use ag instead of grep
set grepprg=ag\ --smart-case

" eliminate clearing of terminal when suspending/quiting
" http://www.shallowsky.com/linux/noaltscreen.html
set t_ti= t_te=


" more info
set list listchars=tab:▸\ ,extends:❯,precedes:❮
set showbreak=↪

" share the unnamed paste buffer with the system clipboard
set clipboard=unnamed

" it's the new standard
set tabstop=2 shiftwidth=2 softtabstop=2

" this makes more sense
set splitright
set splitbelow

" syntax hl can be slowwwww
" set synmaxcol=128

if has("gui_running")
  " don't need that ugly toolbar
  set guioptions-=T
  " always show tabs
  set showtabline=2
  set guifont=Monofur:h18
endif

" switch cursor from block in insert mode
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" This enables iterm cursor changes from vim. In .tmux.conf you'll need:
" set-option -g terminal-overrides '*88col*:colors=88,*256col*:colors=256,xterm*:XT:Ms=\E]52;%p1%s;%p2%s\007:Cc=\E]12;%p1%s\007:Cr=\E]112\007:Cs=\E]50;CursorShape=%?%p1%{3}%<%t%{0}%e%p1%{2}%-%;%d\007'
"
" Source: https://github.com/Casecommons/casecommons_workstation/blob/master/templates/default/dot_tmux.conf.erb
"         https://github.com/Casecommons/vim-config/blob/master/init/tmux.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if exists('$ITERM_PROFILE')
  if exists('$TMUX')
    let &t_SI = "\<Esc>[3 q"
    let &t_EI = "\<Esc>[0 q"
  else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
  endif
end

" assume a fast terminal connection
set ttyfast
set ttimeout
set ttimeoutlen=50

" don't redraw each line when executing macros
set lazyredraw

" show me column 80
if exists('+colorcolumn')
  set colorcolumn=80
endif

" don't assume I want a commented line after a commented line
set formatoptions-=or

" better behavior for the quickfix window and :sb
set switchbuf=useopen

" find a tags file somewhere
set tags+=../tags;/

" ask me if I want to write unsaved changes
set confirm

""" Custom mappings

" prefer , rather than default \
let mapleader = ","

" Suspend in every mode
inoremap <C-z> <ESC>:suspend<CR>
cnoremap <C-z> <ESC>:suspend<CR>

" make split-window editing easier
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-h> <C-w>h
noremap <C-l> <C-w>l

" keep selection after visual in/out-dent
vnoremap > >gv
vnoremap < <gv

" if I'm going to spend this much time tweaking I might as well make it as
" easy as possible
noremap <leader>ev :vsplit $MYVIMRC<CR>
noremap <leader>sv :source $MYVIMRC<CR>

" Bash/readline-like keys for the command line
cnoremap <C-A> <Home>
cnoremap <C-E> <End>
cnoremap <C-K> <C-U>
cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

" Toggle spell checking for the current file
noremap <leader>sc :setlocal spell!<cr>
" move to next misspelled word
noremap <leader>sn ]s
" move to previous misspelled word
noremap <leader>sp [s
" add word to dictionary
noremap <leader>sa zg
" show a list of alternate spellings
noremap <leader>s? z=

" Toggle paste mode for current file
noremap <leader>p :setlocal paste!<cr>

" visually select the last pasted hunk
nnoremap <leader>vp `[v`]

" use ctrl-n/p in normal mode to cycle through the quickfix list
nnoremap <C-n> :cn<CR>
nnoremap <C-p> :cp<CR>

" dts inserts the current timestamp in insert mode
iab <expr> dts strftime("%d-%b %Y %H:%M")

" <c-c> is not exactly equivalent to <esc> - make it so
noremap <c-c> <esc>

" make grep (ag) easier
noremap <leader>f :grep <C-R><C-W>

function! Cleanup()
  " save my current context
  let save_cursor = getpos(".")
  let old_query   = getreg('/')
  " use my tab/space setup on the whole file
  :retab
  " use my indentation setup on the whole file
  :normal gg=G
  " strip trailing whitespace
  :%s/\s\+$//e
  " remove any repeated blank lines
  :%s/\n\{3,}/\r\r/e
  " restore my original context
  call setpos('.', save_cursor)
  call setreg('/', old_query)
endfunction
noremap <leader>cu :silent call Cleanup()<CR>

noremap <leader>cs :SyntasticCheck<CR>

" move by display lines
nnoremap k gk
nnoremap j gj

" hardish mode
inoremap <BS> <nop>

" delete all buffers
nnoremap <leader>bd :bd *<c-a><cr>

function! RenameFile()
  let old_name = expand('%')
  let new_name = input('New file name: ', expand('%'), 'file')
  if new_name != '' && new_name != old_name
    exec ':saveas ' . new_name
    exec ':silent !rm ' . old_name
    redraw!
  endif
endfunction
map <leader>rn :call RenameFile()<cr>

function! Mkdir()
  let dir = expand('%:p:h')
  if !isdirectory(dir)
    call mkdir(dir, "p")
    echo "created directory: " . dir
  endif
endfunction

""" Autocomd/Filetype-specific settings

augroup dowhatimean
  autocmd!
  " if I try to write to a file in a directory that doesn't exist,
  " create it for me
  autocmd BufWritePre * call Mkdir()
augroup END

augroup textmarkdown
  autocmd!
  autocmd BufRead,BufNewFile *.md,*.mkd,*.md.txt setfiletype markdown
  autocmd BufRead,BufNewFile *.txt setfiletype text
  autocmd FileType text,markdown setlocal wrap linebreak autoindent nolist textwidth=80 spell
  autocmd FileType text,markdown setlocal complete+=kspell
augroup END

augroup help
  autocmd!
  autocmd FileType help setlocal nospell
augroup END

augroup makefile
  autocmd!
  autocmd FileType make setlocal noexpandtab
augroup END

augroup rb
  autocmd!
  autocmd BufRead,BufNewFile Vagrantfile,Rakefile,Guardfile,Cheffile setfiletype ruby
  autocmd FileType ruby setlocal makeprg=rspec
  autocmd FileType ruby compiler rspec
augroup END

augroup java
  autocmd!
  " use ~/bin/jtest for small java programs
  autocmd BufRead,BufNewFile *.java set makeprg=jtest\ %
augroup END

augroup cccc
  autocmd!
  " a very simplified make for small c programs
  autocmd BufRead,BufNewFile *.h,*.c set makeprg=make\ %:r
augroup END

augroup js
  autocmd!
  autocmd BufRead,BufNewFile *.json setfiletype javascript
  autocmd FileType javascript setlocal omnifunc=jscomplete#CompleteJS
augroup END

augroup mustache
  autocmd!
  autocmd BufRead,BufNewFile *.html setfiletype mustache
augroup END

augroup gitconfig
  autocmd!
  autocmd BufRead,BufNewFile .gitconfig,gitconfig.symlink setlocal noexpandtab
augroup END

augroup sql
  autocmd!
  autocmd BufRead,BufNewFile */psql.edit.* setfiletype sql
  autocmd BufRead,BufNewFile */sql* setfiletype sql
augroup END

augroup rust
  autocmd!
  autocmd BufRead,BufNewFile *.rs setfiletype rust
augroup END

augroup mail
  autocmd!
  autocmd FileType mail setlocal wrap linebreak autoindent nolist textwidth=72 spell
augroup END

augroup git
  autocmd!
  autocmd FileType gitcommit setlocal spell
augroup END

augroup cukes
  autocmd!
  autocmd FileType cucumber setlocal wrap linebreak nolist textwidth=80 spell
augroup END

augroup curly
  autocmd!
  autocmd BufRead,BufNewFile *.html.curly setfiletype html
augroup END

augroup tabby
  autocmd!
  autocmd BufRead,BufNewFile *.tsv setlocal noexpandtab
augroup END

" Save when losing focus
autocmd FocusLost * :silent! wall

" Only show cursorline & colorcolumn in the current window
augroup cline
  autocmd!
  autocmd WinLeave * setlocal nocursorline colorcolumn=0 norelativenumber number
  autocmd InsertEnter * setlocal norelativenumber number
  autocmd InsertLeave * setlocal relativenumber
  autocmd WinEnter * setlocal cursorline colorcolumn=80 relativenumber
augroup END

" Restore last cursor position
augroup cpos
  autocmd!
  autocmd BufReadPost *
        \ if &filetype !~ '^git\c' && line("'\"") > 1 && line("'\"") <= line("$") |
        \   exe "normal! g`\"" |
        \ endif
augroup END

" put results of :grep in quickfix window
augroup qfgrep
  autocmd!
  autocmd QuickFixCmdPost *grep* cwindow
augroup END

augroup golang
  autocmd!
  autocmd FileType go setlocal noexpandtab nolist
  autocmd FileType go compiler go
augroup END

" Resize splits when the window is resized
augroup resize
  autocmd!
  autocmd VimResized * :wincmd =
augroup END

" Use CtrlPMixed when started without any arguments
augroup ctrlpme
  autocmd!
  autocmd VimEnter *
        \ if argc() == 0 |
        \   :CtrlPMixed |
        \ endif
augroup END

" rails.vim settings
"
" open the 'alternate' (test) files
noremap <leader>as :AS<CR>
noremap <leader>av :AV<CR>
" open the 'related' (template/presenter) files
noremap <leader>rs :RS<CR>
noremap <leader>rv :RV<CR>

" Edit or view files in same directory as current file
cnoremap %% <C-R>=expand('%:h').'/'<cr>
map <leader>de :edit %%<cr>
map <leader>dv :vsplit %%<cr>
map <leader>ds :split %%<cr>

" Map keys to go to specific files
noremap <leader>gr :topleft :split config/routes.rb<cr>
function! ShowRoutes()
  " Requires 'scratch' plugin
  :topleft 100 :split __Routes__
  " Make sure Vim doesn't write __Routes__ as a file
  :set buftype=nofile
  " Delete everything
  :normal 1GdG
  " Put routes output in buffer
  :0r! rake -s routes
  " Size window to number of lines (1 plus rake output length)
  :exec ":normal " . line("$") . "_ "
  " Move cursor to bottom
  :normal 1GG
  " Delete empty trailing line
  :normal dd
endfunction
noremap <leader>rr :silent call ShowRoutes()<cr>
noremap <leader>gg :topleft 100 :split Gemfile<cr>

" needed for textobj-user & textobj-rubyblock
runtime macros/matchit.vim

" Vimux should split horizontally, but only if there isn't already a split
" and only if there is room to split to the side and have two windows open.
if (&columns > (&winwidth * 2) + (&winwidth * 0.25))
  let g:VimuxOrientation = "h"
else
  let g:VimuxOrientation = "v"
endif

" The percent of the screen the split pane Vimux will spawn should take up.
let g:VimuxHeight = "25"

" Vimux should only open a pane when there isn't one already
let g:VimuxUseNearestPane = 1

" The keys sent to the runner pane before running a command. By default it sends
" `q` to make sure the pane is not in scroll-mode and `C-u` to clear the line.
let g:VimuxResetSequence = 'q clear C-u'

" Prompt for a command to run
map <Leader>rp :VimuxPromptCommand<CR>

" Run last command executed by VimuxRunCommand
map <Leader>rl :VimuxRunLastCommand<CR>

" Run makeprog in the same way as vimux
map <Leader>rm :make<CR>

" CommandT
" nnoremap <silent> <Leader>t :CommandT<CR>
" nnoremap <silent> <Leader>b :CommandTBuffer<CR>
" let g:CommandTMatchWindowAtTop = 1
" let g:CommandTBackspaceMap = ['<BS>', '<C-h>']
" let g:CommandTDeleteMap = ['<Del>', '<C-d>']
" let g:CommandTCursorLeftMap = ['<C-b>', '<Left>']
" let g:CommandTCursorRightMap = ['<C-f>', '<Right>']
" let g:CommandTRefreshMap = '<F5>'

" Turbux
let g:no_turbux_mappings = 1
map <leader>rt <Plug>SendTestToTmux
map <leader>rT <Plug>SendFocusedTestToTmux

" Syntastic
let g:syntastic_enable_highlighting = 0
let g:syntastic_auto_loc_list       = 1
let g:syntastic_quiet_messages = {'level': 'warnings'}
let g:syntastic_mode_map = {
      \ 'mode' : 'active',
      \ 'passive_filetypes' : ['sass', 'scss', 'scss.css', 'slim', 'sh']
      \ }

" SQLComplete
let g:omni_sql_no_default_maps = 1
let g:ftplugin_sql_omni_key = '<Tab>'
let g:sql_type_default = 'postgresql'

" DBExt
let g:dbext_default_usermaps = 0

" jscomplete
let g:jscomplete_use = ['dom', 'moz']

" make Netrw prettier/more useful
let NERDTreeHijackNetrw = 1

" disable YCM for most text-type files
let g:ycm_filetype_blacklist = {
      \ 'notes' : 1,
      \ 'markdown' : 1,
      \ 'text' : 1,
      \ 'gitcommit' : 1,
      \ 'mail' : 1,
      \}
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_seed_identifiers_with_syntax = 1

" let g:ycm_autoclose_preview_window_after_completion = 0
let g:ycm_add_preview_to_completeopt = 1

let g:airline_theme='base16'
let g:airline_powerline_fonts=0
let g:airline_left_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''
let g:airline_mode_map = {
    \ '__' : '-',
    \ 'n'  : 'N',
    \ 'i'  : 'I',
    \ 'R'  : 'R',
    \ 'c'  : 'C',
    \ 'v'  : 'V',
    \ 'V'  : 'V',
    \ '' : 'V',
    \ 's'  : 'S',
    \ 'S'  : 'S',
    \ '' : 'S',
    \ }

" Gist.vim
let g:gist_post_private = 1
let g:gist_get_multiplefile = 1
let g:gist_detect_filetype = 1
let g:gist_open_browser_after_post = 1

" delimitMate
let delimitMate_expand_cr = 1

" ctrl-p
let g:ctrlp_match_window = 'top,order:ttb,min:1,max:32'
let g:ctrlp_use_caching = 0
let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
let g:ctrlp_map = '<Leader>t'
let g:ctrlp_cmd = 'CtrlPMixed'
let g:ctrlp_reuse_window = 'netrw'
let g:ctrlp_mruf_relative = 1
nnoremap <silent> <Leader>b :CtrlPBuffer<CR>

" Tabularize
"  NOTES:
"  * \zs is basically a zero-width lookbehind assertion;
"    it eats spaces before the comma/colon/whatever.
"    See: http://vimcasts.org/episodes/aligning-text-with-tabular-vim/
"  * l0c1 is a format specifier that says
"    "left, then zero spaces, then [delimiter], then 1 space"
"    See: https://raw.github.com/godlygeek/tabular/master/doc/Tabular.txt
noremap <leader>a# :Tabularize/#<CR>
vnoremap <leader>a# :Tabularize/#<CR>
noremap <leader>ah :Tabularize/=><CR>
vnoremap <leader>ah :Tabularize/=><CR>
noremap <leader>a= :Tabularize/=<CR>
vnoremap <leader>a= :Tabularize/=<CR>
noremap <leader>a: :Tabularize/:\zs/l0c1<CR>
vnoremap <leader>a: :Tabularize/:\zs/l0c1<CR>
noremap <leader>a, :Tabularize/,\zs/l0c1<CR>
vnoremap <leader>a, :Tabularize/,\zs/l0c1<CR>
