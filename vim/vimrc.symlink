"""
""" CREDITS: @mislav @amix @garybernhardt
"""

""" General Settings
set nomodeline
set nocompatible
set fileencoding=utf-8
set spelllang=en_us

" autoloading
runtime bundle/vim-pathogen/autoload/pathogen.vim
call pathogen#infect()

" Enable filetype detection
filetype plugin indent on

" coding defaults (may be overridden by plugins/filetypes below)
syntax on
set expandtab
set backspace=start,indent,eol
set nowrap

" turn off matching paren highlighting
let loaded_matchparen = 1

" colors
" prefer lighter bg
let g:molokai_original = 1
colorscheme $VIMCOLORS

" more info
set number
set showmode
set showcmd
set ruler
set laststatus=2
set cursorline

" always keep the cursor line in the middle of the screen if possible
set scrolloff=999

" smart(ish) searching
set incsearch
set nohlsearch
set smartcase
set wrapscan

" file & dir matching mode
set wildmode=list:longest

" Make tab completion for files/buffers act like bash/readline
set wildmenu

" remove binary files from completion menus
set wildignore+=*.o,*.obj,.git,*.class,*.png,*.jpg,*.jpeg,*.gif,*.ico,*.pdf,*.doc,*.docx,*.ppt,*.pptx,*.xls,*.xlsx
set wildignore+=vendor,tmp,log
if has('wildignorecase')
  set wildignorecase
endif

" inserts the longest common text of all matches and display menu even if
" there's only one match
set completeopt=longest,menuone,preview

" remember
set history=256

" shut up
set noerrorbells
set novisualbell
set t_vb=

" files - use version control instead
set nobackup
set nowritebackup

"When on a buffer becomes hidden when it is abandoned.
set hidden

" don't litter my working directory
set directory=~/.tmp,/var/tmp,/tmp

" auto-fetch changes from other sources
set autoread

" auto-write when suspending (^Z) etc
set autowrite

" folding > sliced bread
set foldmethod=syntax
set foldlevel=2
set foldnestmax=2

" Make sure the current window is always wide & tall enough
set winwidth=84

" We have to have a winheight bigger than we want to set winminheight. But if
" we set winheight to be huge before winminheight, the winminheight set will
" fail.
set winheight=5
set winminheight=5
set winheight=999

" use ack instead of grep
set grepprg=ack\ --column\ --ignore-case\ --ignore-dir=vendor/ruby
set grepformat=%f:%l:%c:%m

" eliminate clearing of terminal when suspending/quiting
" http://www.shallowsky.com/linux/noaltscreen.html
set t_ti= t_te=

" avoid problems with $PATH
set shell=/bin/bash

" show indentation level on new lines
set list listchars=tab:»-,trail:·,extends:»,precedes:«

" share the unnamed paste buffer with the system clipboard
set clipboard=unnamed

" it's the new standard
set tabstop=2 shiftwidth=2 softtabstop=2

" this makes more sense
set splitright

" syntax hl can be slowwwww
set synmaxcol=256

if has("gui_running")
  " don't need that ugly toolbar
  set guioptions-=T
  " always show tabs
  set showtabline=2
endif

" switch cursor from block in insert mode
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" This enables iterm cursor changes from vim. In .tmux.conf you'll need:
" set-option -g terminal-overrides '*88col*:colors=88,*256col*:colors=256,xterm*:XT:Ms=\E]52;%p1%s;%p2%s\007:Cc=\E]12;%p1%s\007:Cr=\E]112\007:Cs=\E]50;CursorShape=%?%p1%{3}%<%t%{0}%e%p1%{2}%-%;%d\007'
"
" Source: https://github.com/Casecommons/casecommons_workstation/blob/master/templates/default/dot_tmux.conf.erb
"         https://github.com/Casecommons/vim-config/blob/master/init/tmux.vim
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if exists('$ITERM_PROFILE')
  if exists('$TMUX')
    let &t_SI = "\<Esc>[3 q"
    let &t_EI = "\<Esc>[0 q"
  else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
  endif
end

" assume a fast terminal connection
set ttyfast

" don't redraw each line when executing macros
set lazyredraw

""" Custom mappings

" prefer , rather than default \
let mapleader = ","

" Suspend in every mode
inoremap <C-z> <ESC>:suspend<CR>
cnoremap <C-z> <ESC>:suspend<CR>

" make split-window editing easier
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-h> <C-w>h
noremap <C-l> <C-w>l

" keep selection after visual in/out-dent
vnoremap > >gv
vnoremap < <gv

" if I'm going to spend this much time tweaking I might as well make it as
" easy as possible
noremap <leader>ev :split $MYVIMRC<CR>
noremap <leader>sv :source $MYVIMRC<CR>

" Bash/readline-like keys for the command line
cnoremap <C-A> <Home>
cnoremap <C-E> <End>
cnoremap <C-K> <C-U>
cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

" Toggle spell checking for the current file
noremap <leader>sc :setlocal spell!<cr>
" move to next misspelled word
noremap <leader>sn ]s
" move to previous misspelled word
noremap <leader>sp [s
" add word to dictionary
noremap <leader>sa zg
" show a list of alternate spellings
noremap <leader>s? z=

" Toggle paste mode for current file
noremap <leader>p :setlocal paste!<cr>

" make make easier
noremap <leader>m :make<cr>

" Switch between the last two files
nnoremap <leader><leader> <c-^>

" visually select the last pasted hunk
nnoremap <leader>vp `[v`]

" use ctrl-n/p in normal mode to cycle through the quickfix list
nnoremap <C-n> :cn<CR>
nnoremap <C-p> :cp<CR>

" ctrlp won
nnoremap <silent> <Leader>t :CtrlP<CR>
nnoremap <silent> <Leader>b :CtrlPBuffer<CR>

" dts inserts the current timestamp in insert mode
iab <expr> dts strftime("%d-%b %Y %H:%M")

function! Cleanup()
  " save my current context
  let save_cursor = getpos(".")
  let old_query   = getreg('/')
  " use my tab/space setup on the whole file
  :retab
  " use my indentation setup on the whole file
  :normal gg=G
  " strip trailing whitespace
  :%s/\s\+$//e
  " remove any repeated blank lines
  :%s/\n\{3,}/\r\r/e
  " restore my original context
  call setpos('.', save_cursor)
  call setreg('/', old_query)
endfunction
noremap <leader>cu :silent call Cleanup()<CR>

noremap <leader>cs :SyntasticCheck<CR>

""" Autocomd/Filetype-specific settings

augroup textmarkdown
  autocmd!
  autocmd BufRead,BufNewFile *.md,*.mkd,*.md.txt setfiletype markdown
  autocmd BufRead,BufNewFile *.txt setfiletype text
  autocmd FileType text,markdown setlocal textwidth=78 spell wrap wrapmargin=2 linebreak autoindent
augroup END

augroup help
  autocmd!
  autocmd FileType help setlocal nospell
augroup END

augroup makefile
  autocmd!
  autocmd FileType make setlocal noexpandtab tabstop=8 shiftwidth=8 softtabstop=8
augroup END

augroup rb
  autocmd!
  autocmd BufRead,BufNewFile Vagrantfile,Rakefile,Guardfile,Cheffile setfiletype ruby
  autocmd FileType ruby setlocal makeprg=rspec\ spec
augroup END

augroup java
  autocmd!
  " use ~/bin/jtest for small java programs
  autocmd BufRead,BufNewFile *.java set makeprg=jtest\ %
augroup END

augroup cccc
  autocmd!
  " a very simplified make for small c programs
  autocmd BufRead,BufNewFile *.h,*.c set makeprg=make\ %:r
augroup END

augroup js
  autocmd!
  autocmd BufRead,BufNewFile *.json setfiletype javascript
  autocmd FileType javascript setlocal omnifunc=jscomplete#CompleteJS
augroup END

augroup mustache
  autocmd!
  autocmd BufRead,BufNewFile *.html setfiletype mustache
augroup END

augroup gitconfig
  autocmd!
  autocmd BufRead,BufNewFile .gitconfig,gitconfig.symlink setlocal noexpandtab tabstop=8 shiftwidth=8 softtabstop=8
augroup END

augroup psql
  autocmd!
  autocmd BufRead,BufNewFile psql.edit.* setfiletype sql
augroup END

" Restore cursor position
autocmd BufReadPost *
      \ if line("'\"") > 1 && line("'\"") <= line("$") |
      \   exe "normal! g`\"" |
      \ endif

" use ft-syntax-omni if no omnifunc is defined
if exists("+omnifunc")
  autocmd Filetype *
        \ if &omnifunc == "" |
        \   setlocal omnifunc=syntaxcomplete#Complete |
        \ endif
endif

""" Plugin settings

" setup omnicomplete for ruby/rails
let g:rubycomplete_buffer_loading = 1
let g:rubycomplete_classes_in_global = 1
let g:rubycomplete_rails = 1

" rails.vim settings
"
" open the 'alternate' (test) file in a split window
noremap <leader>as :AS<CR>
" open the 'alternate' (test) file in a vertical split window
noremap <leader>av :AV<CR>

" Edit or view files in same directory as current file
cnoremap %% <C-R>=expand('%:h').'/'<cr>
noremap <leader>e :edit %%

" Map keys to go to specific files
noremap <leader>gr :topleft :split config/routes.rb<cr>
function! ShowRoutes()
  " Requires 'scratch' plugin
  :topleft 100 :split __Routes__
  " Make sure Vim doesn't write __Routes__ as a file
  :set buftype=nofile
  " Delete everything
  :normal 1GdG
  " Put routes output in buffer
  :0r! rake -s routes
  " Size window to number of lines (1 plus rake output length)
  :exec ":normal " . line("$") . "_ "
  " Move cursor to bottom
  :normal 1GG
  " Delete empty trailing line
  :normal dd
endfunction
noremap <leader>gR :silent call ShowRoutes()<cr>
noremap <leader>gg :topleft 100 :split Gemfile<cr>

" Sets whether or not to pre-highlight the first match when completeopt has
" the popup menu enabled and the 'longest' option as well. When enabled, <tab>
" will kick off completion and pre-select the first entry in the popup menu,
" allowing you to simply hit <enter> to use it.
let g:SuperTabLongestHighlight = 1

" When enabled and 'longest' is in your |completeopt| setting, supertab will
" provide an enhanced longest match support where typing one or more letters
" and hitting tab again while in a completion mode will complete the longest
" common match using the new text in the buffer.
let g:SuperTabLongestEnhanced = 1

" Split the CoffeeCompile buffer vertically by default.
let coffee_compile_vert = 1

" This option defines which set of symbols and dividers you want to use. There
" are currently three available options: "compatible", "unicode" and "fancy".
"
"     TYPE           DESCRIPTION
"     compatible     Doesn't use any special characters.
"     unicode        Simulates icons and arrows using similar unicode glyphs.
"     fancy          Custom icons and arrows. Requires a patched font.
let g:Powerline_symbols = "fancy"

" needed for textobj-user & textobj-rubyblock
runtime macros/matchit.vim

" Vimux should split horizontally, but only if there isn't already a split
" and only if there is room to split to the side and have two windows open.
if (&columns > (&winwidth * 2) + (&winwidth * 0.25))
  let g:VimuxOrientation = "h"
else
  let g:VimuxOrientation = "v"
endif

" The percent of the screen the split pane Vimux will spawn should take up.
let g:VimuxHeight = "25"

" Vimux should only open a pane when there isn't one already
let g:VimuxUseNearestPane = 1

" The keys sent to the runner pane before running a command. By default it sends
" `q` to make sure the pane is not in scroll-mode and `C-u` to clear the line.
let g:VimuxResetSequence = 'q C-l C-u'

" Prompt for a command to run
map <Leader>rp :VimuxPromptCommand<CR>

" Run last command executed by VimuxRunCommand
map <Leader>rl :VimuxRunLastCommand<CR>

" Ctrl-P
let g:ctrlp_map = '<c-t>'
" I know where I want to search!
let g:ctrlp_working_path_mode = 0
let g:ctrlp_max_files = 5000

" Turbux
let g:no_turbux_mappings = 1
map <leader>rt <Plug>SendTestToTmux
map <leader>rT <Plug>SendFocusedTestToTmux

" Syntastic
let g:syntastic_enable_highlighting = 0
let g:syntastic_auto_loc_list=1
let g:syntastic_mode_map = { 'mode': 'passive',
      \ 'active_filetypes': ['javascript'],
      \ 'passive_filetypes': [] }

" SQLComplete
let g:ftplugin_sql_omni_key = '<Tab>'
let g:sql_type_default = 'postgresql'

" DBExt
let g:dbext_default_usermaps = 0

" jscomplete
let g:jscomplete_use = ['dom', 'moz']
